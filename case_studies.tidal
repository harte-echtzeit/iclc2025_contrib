-- a simple case study for the petri net >> notation test


-- a simple track

-- a drum kit
d1 $ fast 1.25
  $ stack[
  -- sometimes (echo 4 0.3 0.8) $
  s "cpu2:0*4" # gain "1 0.8 1 0.8",
  s "cpu2:3(5,8)",
  s "clubkick ~ clubkick ~" # gain 0.8]
  # gain 0.7
  -- # comb (iclc/(pat2*9))

let pat = "3 4 2 5"

let pat1 = "i c l c"

let iclc = "9 3 12 3"

let pat2 = "2 0 2 5"

let iclc2 = [9,3,12,3]
    pat23 = [2,0,2,5]

-- a bass line
d2 $ fast 1
  $ note (squeeze "0 1" [iclc,pat2])
  -- $ arp "downup"
  -- $ note (pat2 <> iclc)
  # s "bass3"
  # cut 1
  -- # fshift "<100 80 50>"
  # gain 0.9
  # room (range 0.1 0.4 sine)
  # pan (fast 2 $ perlin)

$ arp "updown"


d2 $ every 4 ((# note "1 3 4 4"))
  -- $ note a
  # s "superpiano"


hush


--- try to inject a different pattern while running
let a = iclc

let a = pat2

d1 $ n a # s "superpiano"

d1 $ qtrigger $ seqPLoop [
  (0, 12, sound "bd bd*2"),
  (4, 12, sound "hh*2 [sn cp] cp future*4"),
  -- (8, 12, sound (samples "arpy*8" (run 16))),
  (8, 16, n a # s "superpiano")]


-- a simple boolean pattern switch
patChoose x = if x==1 then iclc else pat2

do
  let a = 2
  d1 $ fast 1.5 $ note (patChoose a) #  s "superpiano" # legato 2 # gain 0.8
  d2 $ qtrigger $ seqPLoop [(0, 12, sound "bd bd*2"),
                            (4, 12, sound "hh*2 [sn cp] cp future*4"),
                            (8, 16, n (patChoose 0) # s "superpiano")]

hush


--introduce petri nets here DEFs

place in_num curr_num max_num
  | in_num + curr_num <= 0 = False
  | in_num + curr_num > max_num = False
  | otherwise = True

-- maybe use and perform change of curr_nums in places
trans in_state = if in_state then 1 else 0

-- example of an resulting place, parametrized (dummy wrapper)
linP b = place (trans (place b b 1)) b 1



--- >>>> A) example one: simple switch

let iclc = "9 3 12 3"
    twentyFive = "2 0 2 5"

-- a simple boolean pattern switch
patChoose x = if x then iclc else twentyFive

musicalAction pat_in =
  d1 $ fast 2
  $ note pat_in
  # s "bass3"
  # cut 1

do
  let trig = linP 1
  musicalAction (patChoose trig)




--- B) example two: choice between multiple out puts

import System.Random (randomRIO)

randomTrigger :: IO Int
randomTrigger = randomRIO (0 :: Int,1 :: Int)  -- Randomly choose 1 or 2

-- a tuple of two linear petri-net options
polyP c d = (linP c, linP d)


musicalAction trig1 trig2
 | trig1 && trig2 = do
      d1 $ s "bd sd ~ bd"  -- First pattern triggered on d1
      d2 $ s "hh*3 cp"     -- Second pattern triggered on d2
  | trig1 = do
      d1 $ s "bd sd ~ bd"
      d2 $ silence
  | trig2 = do
      d2 $ s "hh*3 cp"
      d1 $ silence
  | otherwise = do
      d1 $ silence
      d2 $ silence


--- random version         
do
  a <- randomTrigger
  b <- randomTrigger
  print(a, b)
  let (track1, track2) = polyP a b
  musicalAction track1 track2


-- user defined version
do
  let (track1, track2) = polyP 0 0
  musicalAction track1 track2



--- C) recursive eecution of a musical action
import Control.Concurrent

-- calculate the cycle time based on the standard CPS rate
cycTime = round(1/0.5625)

musicalAction num = if num > 0
  then do
    d1 $ s "bd clubkick bd sn"
    threadDelay (cycTime * 1000000)
    d1 $ silence
    musicalAction (num-1)
  else d1 $ silence

do
  musicalAction 5
