-- a simple case study for the petri net >> notation test


-- a simple track

-- a drum kit
d1 $ fast 1.25
  $ stack[
  -- sometimes (echo 4 0.3 0.8) $
  s "cpu2:0*4" # gain "1 0.8 1 0.8",
  s "cpu2:3(5,8)",
  s "clubkick ~ clubkick ~" # gain 0.8]
  # gain 0.7
  -- # comb (iclc/(pat2*9))

let pat = "3 4 2 5"

let pat1 = "i c l c"

let iclc = "9 3 12 3"

let pat2 = "2 0 2 5"

let iclc2 = [9,3,12,3]
    pat23 = [2,0,2,5]

-- a bass line
d2 $ fast 1
  $ note (squeeze "0 1" [iclc,pat2])
  -- $ arp "downup"
  -- $ note (pat2 <> iclc)
  # s "bass3"
  # cut 1
  -- # fshift "<100 80 50>"
  # gain 0.9
  # room (range 0.1 0.4 sine)
  # pan (fast 2 $ perlin)

$ arp "updown"


d2 $ every 4 ((# note "1 3 4 4"))
  -- $ note a
  # s "superpiano"


hush


--- try to inject a different pattern while running
let a = iclc

let a = pat2

d1 $ n a # s "superpiano"

d1 $ qtrigger $ seqPLoop [
  (0, 12, sound "bd bd*2"),
  (4, 12, sound "hh*2 [sn cp] cp future*4"),
  -- (8, 12, sound (samples "arpy*8" (run 16))),
  (8, 16, n a # s "superpiano")]


-- a simple boolean pattern switch
patChoose x = if x==1 then iclc else pat2

do
  let a = 2
  d1 $ fast 1.5 $ note (patChoose a) #  s "superpiano" # legato 2 # gain 0.8
  d2 $ qtrigger $ seqPLoop [(0, 12, sound "bd bd*2"),
                            (4, 12, sound "hh*2 [sn cp] cp future*4"),
                            (8, 16, n (patChoose 0) # s "superpiano")]

hush
